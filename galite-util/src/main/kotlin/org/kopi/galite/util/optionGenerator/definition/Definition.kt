/*
 * Copyright (c) 2013-2024 kopiLeft Services SARL, Tunis TN
 * Copyright (c) 1990-2024 kopiRight Managed Solutions GmbH, Wien AT
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

package org.kopi.galite.util.optionGenerator.definition

import java.io.File
import java.io.PrintWriter
import java.util.*
import org.jdom2.Document
import org.jdom2.Element
import org.jdom2.input.SAXBuilder
import org.kopi.galite.util.base.InconsistencyException
import org.kopi.galite.util.optionGenerator.utils.OptgenError

internal class DefinitionFile(private val sourceFile: String,
                              private val fileHeader: String?,
                              val packageName: String,
                              private val parent: String?,
                              val prefix: String,
                              private var version: String?,
                              private val usage: String?,
                              private val definitions: Array<OptionDefinition?>) {

  fun setVersion(version: String?) {
    this.version = version
  }

  @Throws(OptgenError::class)
  fun checkIdentifiers() {
    val identifiers = Hashtable<String, String>()
    definitions.forEach { it?.checkIdentifiers(identifiers, sourceFile) }
  }

  @Throws(OptgenError::class)
  fun checkShortcuts() {
    val shortcuts = Hashtable<String, String>()
    definitions.forEach { it?.checkShortcuts(shortcuts, sourceFile) }
  }

  /**
   * Generates the option parser.
   *
   * @param    out        the output stream
   */
  fun printFile(out: PrintWriter) {
    if (fileHeader != null) {
      out.println(fileHeader)
    }
    out.print("// Generated by optgen from $sourceFile")
    out.println()
    out.println("package $packageName;")
    out.println()
    out.println("import gnu.getopt.Getopt;")
    out.println("import gnu.getopt.LongOpt;")
    out.println()
    out.print("public class " + prefix + "Options")
    out.print(if (parent == null) "" else " extends $parent")
    out.println(" {")

    // CONSTRUCTORS
    out.println()
    out.println("  public " + prefix + "Options(String name) {")
    out.println("    super(name);")
    out.println("  }")
    out.println()
    out.println("  public " + prefix + "Options() {")
    out.println("    this(\"$prefix\");")
    out.println("  }")
    out.println()

    // FIELDS
    for (i in definitions.indices) {
      definitions[i]!!.printFields(out)
    }

    // PROCESSOPTION
    out.println()
    out.println("  public boolean processOption(int code, Getopt g) {")
    out.println("    switch (code) {")
    for (i in definitions.indices) {
      definitions[i]!!.printParseArgument(out)
    }
    out.println("    default:")
    out.println("      return super.processOption(code, g);")
    out.println("    }")
    out.println("  }")


    // GETOPTIONS
    out.println()
    out.println("  public String[] getOptions() {")
    out.println("    String[]	parent = super.getOptions();")
    out.println("    String[]	total = new String[parent.length + " + definitions.size + "];")
    out.println("    System.arraycopy(parent, 0, total, 0, parent.length);")
    for (i in definitions.indices) {
      out.print("    total[parent.length + $i] = ")
      definitions[i]!!.printUsage(out)
      out.println(";")
    }
    out.println("    ")
    out.println("    return total;")
    out.println("  }")

    // GETSHORTOPTIONS
    out.println("\n")
    out.println("  public String getShortOptions() {")
    out.print("    return \"")
    for (i in definitions.indices) {
      definitions[i]!!.printShortOption(out)
    }
    out.println("\" + super.getShortOptions();")
    out.println("  }")

    // VERSION
    out.println("\n")
    out.println("  public void version() {")
    out.print("    System.out.println(")
    out.print(if (version == null) "" else "\"" + version + "\"")
    out.println(");")
    out.println("  }")

    // USAGE
    out.println("\n")
    out.println("  public void usage() {")
    if (usage != null) {
      out.print("    System.err.println(")
      out.print("\"" + usage + "\"")
      out.println(");")
    }
    out.println("  }")

    // GETLONGOPTIONS
    out.println()
    out.println("  public LongOpt[] getLongOptions() {")
    out.println("    LongOpt[]	parent = super.getLongOptions();")
    out.println("    LongOpt[]	total = new LongOpt[parent.length + LONGOPTS.length];")
    out.println("    ")
    out.println("    System.arraycopy(parent, 0, total, 0, parent.length);")
    out.println("    System.arraycopy(LONGOPTS, 0, total, parent.length, LONGOPTS.length);")
    out.println("    ")
    out.println("    return total;")
    out.println("  }")

    // LONGOPTS
    out.println()
    out.println("  private static final LongOpt[] LONGOPTS = {")
    for (i in definitions.indices) {
      if (i != 0) {
        out.println(",")
      }
      definitions[i]!!.printLongOpts(out)
    }
    out.println()
    out.println("  };")

    out.println("}")
  }

  val className: String
    get() = "$packageName.${prefix}Options"

  companion object {
    @Throws(OptgenError::class)
    fun read(sourceFile: String): DefinitionFile {
      val document: Document
      val builder = SAXBuilder()
      try {
        document = builder.build(File(sourceFile))
      } catch (e: Exception) {
        throw InconsistencyException("Cannot load file $sourceFile: ${e.message}")
      }
      val root = document.rootElement

      return DefinitionFile(
        sourceFile,
        root.getAttributeValue("fileHeader"),
        root.getAttributeValue("package"),
        root.getAttributeValue("parent"),
        root.getAttributeValue("prefix"),
        root.getAttributeValue("version"),
        root.getAttributeValue("usage"),
        getOptions(root)
      )
    }

    fun getOptions(element: Element): Array<OptionDefinition?> {
      val params = element.getChildren("param")
      return Array(params.size) { i ->
        val current = params[i] as Element
        val type = current.getAttributeValue("type")
        val isMultiple = current.getAttributeValue("multiple") != null
        val arg = current.getAttributeValue("optionalDefault") ?: if (type != "boolean") "" else null
        OptionDefinition(
          current.getAttributeValue("longname"),
          current.getAttributeValue("shortname"),
          type,
          isMultiple,
          current.getAttributeValue("default"),
          arg,
          current.getAttributeValue("help")
        )
      }
    }
  }
}
