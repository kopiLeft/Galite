=== Visual Galite Forms

The aim of Galite is to enable you to create applications. An application is made up of forms. A *form* is a set of *pages* consisting of *blocks*. A *block* is nothing else than a table which is divided into columns (vertical) and rows (horizontal). A row is made up of *fields*, and each *field* contains a data value at the intersection of a row and a column that can be of different *Types*.
By the end of this chapter, you will learn how to create a form, but before, you need to learn how to create a field and how to form blocks.

==== Creating Form Fields

In Visual Galite, a fields are containers in which you can define different types of data. A field definition begins with an SimpleName followed by an access modifier that contain in parentheses the domain and the position of the field in the block, and ends the field definition in braces.

*Syntax*
[source,kotlin]
----
val ts = hidden(domain = INT(20)) {
    label = "ts"
    help = "The user ts"
    value = 0
    columns(u.ts)
  }

FieldDeclaration  : val fieldName = AccessModifier("FieldDomain", [FieldPosition]) "{"
                    FieldBody
                    "}"

FieldBody         : [FieldLabel] [FieldHelp] [FieldAlignment]
                    [FieldDropList]     [FieldOptions]    [FieldColumns] 
                    [FieldCommands] [FieldTriggers]
----

===== Field Access Modifiers
An access modifier determines the way the application user will have to handle each field in a form as well as the field accessibility. This command is compulsory. There are 4 sorts of access modifier:

*Syntax:*
[source,kotlin]
----
AccessModifier:   "mustFill"
                  |
                  "visit"
                  |
                  "skipped"
                  |
                  "hidden"
----

 * mustFill : As indicated, a MUSTFILL field has to be filled by the user.
 * visit    : A VISIT field is a field which the user can fill if he wants to.
 * skipped  : A SKIPPED field is a field which is displayed on the form but which the user can not overwrite. A field is skipped if the user needs to know the information written in it.
 * hidden   : A HIDDEN field that is not displayed on the form as the information it provides is of no importance for the user, this kind of fields is usually used for database table join operations or for ID fields.

As the user moves from a field to another when filling the form, the current field is always colored in red.

*Example*
 	
[source,kotlin]
----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
  ...
}
   
val id = hidden(domain = INT(20)) {
  ...
}
----

===== Field Position

This entry defines the position of the field in the current block. HIDDEN fields does not have positions, and in multiple block (Defined in the  Blocks creation Section of this document) you may use the NO DETAIL Block option to pass positioning fields.
There are two possibilities to define the field position.

*Syntax:*
[source,kotlin]
----
FieldPosition : "at" "(<)"Integer row  [,Integer column [-Integer multi]]")"
                | "follow(" SimpleName ")"
----

 * *Absolute Position With at*

You can define it according to one integer or more: ::

 ** at(Integer row)
 ** at(Integer row , Integer column)
 ** at(Integer row, Integer column-Integer multifield)

*Example*
 	
[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1-4)) {
  ...
}
----
The first integer indicates the row number while the second defines the column. 
In fact, Galite automatically divides up the window in rows and columns when setting up a form. +
 When defining the width of a column, thus,
it always adopts the width of the longest field. Since the form wide is not unlimited,
you can put a long field in two or more columns in order to spare place as it is the case in the example above and it is usually used for multiple fields.

 * *Relative Position With follow*

You can also make use of the following structure : follow (SimpleName)

*Example*
 	
[source,kotlin]
----
val age = visit(domain = INT(3), position = follow(name)) {
  ...
}
----
If you enter a new field with this option (in this case it would be the field "name"), it means that this field will be placed directly next to the first field defined by the follow property (field "Name") on the same row. The two fields will then form one single column.

===== Field label

The field label is optional, you declare it with the label property inside the field body, the syntax is the following :

*Syntax*
[source,kotlin]
----
FieldLabel : "label" "=" nomDuField : String
----

If you don't want your field to have a label, you can set the property label to empty.

*Example*
[source,kotlin]
----
val secondName = visit(domain = STRING(20), position = at(1, 1)) {
    label = "The second Name","another Label for this field"
    ...
  }
----

===== Field Help Text

this property is used to insert an explanation text for the application user in order to help him filling in the form. This Help text will then be displayed when the user places the mouse on the field.

*Syntax:*
 	
[source,kotlin]
----
HelpText:   "help" "=" HelpText : String
----
*Example*
 	
[source,kotlin]
----
val lesson = visit(domain = STRING(20), position = at(1, 1)) {
    label = "lesson"
    help =  "The lesson you would like to attend"
    ...
  }
----

===== Field Types

The field type is a required entry, you may enter a predefined field type :

*Example*
[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1)) {
    ...
}
val age = visit(domain = INT(3), position = at(1, 2)) {
    ...
}
----

You can also use self defined field types that you have previously defined in the type definition section of your form.

*Example*
[source,kotlin]
----
val day = mustFill(domain = Days, position = at(1, 1)) {
    label = "day"
    help = "The day"
}
----

In this example, Days is a type you should have defined previously in type definition section of the form using standard types, CODE types and SELECT command ...

===== Field Alignment

This property is used to define the localization of the field's content inside the field. There are three types of alignment.

* FieldAlignment.RIGHT the value is displayed at the right inside the field
* FieldAlignment.LEFT the value is displayed at the left inside the field
* FieldAlignment.CENTER the value is centered in the field

*Example*
[source,kotlin]
----
val name = visit(domain = STRING(20), position = at(1, 1)) {
    label = "name"
    align = FieldAlignment.LEFT
}
----

=====  Field Drop files

This command is used to make a field accept to drop files into it, meaning you can drag files and drop them in your field.

*Syntax:*
[source,kotlin]
----
DroppableDefinition : "droppable" ExtensionList
ExtentionList       : extension : String [,ExtenstionList]
----
*Example*
[source,kotlin]
----

val cv = visit(domain = STRING(20), position = at(4, 1)) {
    label = "Cv"
    help = "The user curriculum vitae"
    columns(u.cv)
    droppable("pdf")
    trigger(ACTION) {
      FileHandler.fileHandler!!.openFile(form.model.getDisplay()!!, object : FileHandler.FileFilter {
        override fun accept(pathname: File?): Boolean {
          return (pathname!!.isDirectory
                  || pathname.name.toLowerCase().endsWith(".pdf"))
        }

        override val description: String
          get() = "PDF"
      })
    }
}
----
In this example, you can drag pdf files and drop them in the field named "cv".

===== Field Options
 
In this part of the field definition, you can use one or more option from the 10 options available for fields in Galite, here is the a list of these field options defined under the class FieldOption and that you can use them by declaring the function options().

 * NOECHO               : If this option is used, characters typed in the field will not be displayed and a star(*) will be displayed instead, this option is useful for password fields.
 * NOEDIT               : This option makes it impossible to change the data of the field or to overwrite it.
 * SORTABLE             : This option adds two opposed arrows icons(up and down) just before the field, clicking on the icon changes the way data are sorted in the field, you can click the icon three times to have ascending sort, descending sort and default sort, 
 * TRANSIENT            : This option make the field transient, meaning that the system can no trail it, if a transaction  calls this field and then this transaction is aborted, the field will not be able to backup or roll-back to its original value, besides this option makes changes ignored for this field.
 * NO DELETE ON UPDATE  : If the field is a lookup is a column of a lookup table, using this option prevent the system to clear the field when inserting new rows or updating rows.
 * NO DETAIL            : If the block is in detailed, using this option on a field make it invisible in the detail.
 * NO CHART             : If the block is multiple, using this option on a field exclude it from the chart. 
 * QUERY UPPER          : Whatever the string you input, this option will make Galite transform it to capital letters.
 * QUERY LOWER          : the opposite of the previous option it transform strings to lower case.

*Example*
[source,kotlin]
----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
    label = "password"
    help = "The user password"
    options(FieldOption.NOECHO)
}
----

===== Field Columns

The columns method option is used to establish a connection between a certain column in the database with the field.Once such connection established, the field will have a direct access to the database column allowing insertions, modification ...+
You may enter this option in order to specify which table and which column the field refers. +
The same field can refer to more than one column.
 You can also use the key method option to specify a key column in the database or the nullable method option to specify an outer joint.+
Two more option are available with the COLUMNS command, the index and the priority options.

*Syntax:*
 	
[source,kotlin]
----
FieldColumns : "columns (" (ColumnList) ") {"
                    columnsBody
                "}"

columnsBody  : [ColumnIndex] [ColumnPriority]

ColumnList   : Column  [, Column ]
Column       : ["KEY (QualifiedName)"] ["NULLABLE (QualifiedName)"]
----
*Example*
 	
[source,kotlin]
----
 val id = hidden(domain = INT(20)) {
    label = "id"
    help = "The user id"
    columns(u.id)
}
----

NOTE: that a field can be connected to more than one table and column. In this case, the formula you will type will be:

*Example*
 	
[source,kotlin]
----
val id = hidden(domain = INT(20)) {
    label = "id"
    help = "The user id"
    columns(I.NumInvoice, ID.Invoice)
}
----
In this example, I is the invoices table  and IP is the invoice details table and they have an outer join connection throw columns NumInvoice and Invoice.

 * *Indexes*

This option is used to define a value in the database which is to remain unique so that it can not appear anymore in another field of the same column. you need to use the index method to declare an index in Galite.

Letâ€™s sum up with the following syntax:

*Syntax:*
 	
[source,kotlin]
----
ColumnIndex : "val i = index(message : String)"
----

If two or more fields are given the same index value, it means that two similar combinations of these field values will not be accepted.

For example, two different lessons cannot be given in the same room. In this case, the three fields, namely the fields "professor", "time" and "lesson" are to be attributed the same index. Thus, at least one of the three values needs to be changed so that the combination can be accepted by the machine. 

*Example*
 	
[source,kotlin]
----
val i = index(message = "this should be unique")"

val lesson = mustFill(domain = INT(11), position = at(1, 1)) {
    label = "Lesson"
    help = "The lesson you have to attend to"
    COLUMN (LEC.Lesson)  {
        index = i
    }
}

val lecturer = mustFill(domain = INT(11), position = at(2, 1)) {
    label = "Lecturer"
    COLUMN (LES.Lecturer)  {
        index = i
    }
}

val time = mustFill(domain = STRING(20), position = at(3, 1)) {
    label = "Time"
    help = "The lesson you have to attend to"
    COLUMN (LES.Time)  {
        index = i
    }
}
----
//-------------------------------> TO CHECK HOW TO PUT 2 INDEX WITH GALITE !!!!!!!!!
However, this example would implicate a professor can give two different lessons at the same time. In order to avoid such errors, you can attribute one field two or more indexes. So you can associate the two fields "professor" and "time" together. Thus, you will have: 

*Example*
 	
[source,kotlin]
----
MUSTFILL "Lesson"
  LABEL 
  HELP "The lesson you have to attend to"
  LONG (11)
  COLUMN (LEC.Lesson)
INDEX 0
END FIELD

VISIT "Lecturer"
  LABEL
  LONG
  COLUMN (T.Lecturer)
  INDEX 0 1
END FIELD

MUSTFILL "Time"
  STRING
  COLUMN (LEC.Time)
  INDEX 1
END FIELD
----
In this case, notice that the "Lecturer" field has been associated 
with two indexes: 0 and 1.

The index value is ascendant. When attributing an index value to a field combination, you shall always take the value nexting that you have taken the last.

 * *Priority*

*Syntax:*
 	
[source,kotlin]
----
ColumnPriority:   "PRIORITY" ["-"] Integer priority 
----
This option is used in order to define the column order within a list when this list is displayed. A PRIORITY is always followed by an integer according to the structure given above. The column with the biggest priority value will appear on the extreme left side of the table and the one with the least value will be on the extreme right side.

We shall notice that negative values are also permitted in this option. However, the minus sign ("-") standing before the number does not have any influence over its value but simply indicates the way all the information will be sorted out within a column. Actually, the different fields are always sorted in the ascending way, i.e from A to Z in case of an alphabetical text and from 1 to x+1 for numbers. Now, if the integer is preceded by a minus, the column content will be sorted in the other way round.

*Example*
 	
[source,kotlin]
----
val i = index(message = "this should be unique")"

val surname = mustFill(domain = STRING(20), position = at(1, 1)) {
    label = "Surname"
    COLUMN (User.Surname)  {
        priority = 3
    }
}
----

If columns "Surname", "Name" and "Date of Birth" are 
respectively given the priorities 3,4 and 1, "Name" will come
first and will be followed by "Surname" and "Date of Birth".
The same order applies with the values 3, -4 and 1, with the only
difference that the names will be sorted out from Z to A.

Moreover, two columns with the same priority will be displayed according to the same order in which the user has listed them.

===== Field Commands

Once you have defined the columns , you may define the field commands.

*Syntax:*
 	
[source,kotlin]
----
Command         : "command (item : String) {"
                    CommandBody
                  "}"

CommandBody     :   CommandAction [AccessMode]

CommandAction   : "action" [(Parameter)] { KotlinCode  }

AccessMode      : "mode(" ListOfModes ")"
----

===== Standard Field Command

The command QualifiedNames that we will can be Galite predefined commands or you can make new Actors and commands you can use in the field command definition.
There are five ways in calling a standard command

[source,kotlin]
----
"command" (item = SimpleName) { "action" (VField SimpleName) {Kotlin Code} }

Example
command(item = clear) {
        mode(VConstants.MOD_UPDATE, VConstants.MOD_INSERT, VConstants.MOD_QUERY)
        action = {
           ...
          }
        }
----

===== Field Command using Modes

All the previous command definition ways can be preceded by one mode or more. There are three sorts of mode which are to be sorted according to the following hierarchy:

 * QUERY to start an inquiry within the database
 * INSERT to create a new row in the database
 * UPDATE to enter new information within a row 

So you will have: ON Mode COMMAND, ON MODE QualifiedName ...

*Example*
 	
[source,kotlin]
----
command(item = insertMode) {
        mode(VConstants.MOD_UPDATE, VConstants.MOD_QUERY)
}
----

If you have entered a mode before the COMMAND, it means this COMMAND can only be invoked if the block is in the mode you have determined.

===== Field Access modifiers using Modes

This method type is used to change the access to the field using the block Mode. In fact the access is not changed directly but the higher access possible is set to the indicated access.

We have 12 method allow us to change the visibility of our field :

 * onQueryHidden()              : in mode Query set field to Hidden access
 * onQuerySkipped()             : in mode Query set field to Skipped access
 * onQueryVisit()               : in mode Query set field to Visit access
 * onQueryMustFill()            : in mode Query set field to MustFill access
 * onInsertHidden()             : in mode Insert set field to Hidden access
 * onInsertSkipped()            : in mode Insert set field to Skipped access
 * onInsertVisit()              : in mode Insert set field to Visit access
 * onInsertMustFill()           : in mode Insert set field to MustFill access
 * onUpdateHidden()             : in mode Update set field to Hidden access
 * onUpdateSkipped()            : in mode Update set field to Skipped access
 * onUpdateVisit()              : in mode Update set field to Visit access
 * onUpdateMustFill()           : in mode Update set field to MustFill access

*Example*
[source,kotlin]
----
 val file = visit(domain = STRING(25), position = at(3, 1)) {
      label = "test"
      help = "The test"
      onQueryHidden()
      onInsertHidden()
}
----
In this example, we have determined that the field will be invisible
if the block is in the QUERY  or the INSERT mode.

===== Field Triggers

Triggers are events that you can use to execute actions when they occur, there are field triggers, block triggers and form triggers that you can use following this syntax : 

*Syntax*
[source,kotlin]
----
Trigger      : "trigger (" EventList ")" TriggerAction

EventList    : Event [,EventList]

TrigerAction : {KOTLIN code}
----

Field Triggers are events that concern the fields behavior, here is a list of all Galite field triggers available :

  * PREFLD     : is executed upon entry of field

  * POSTFLD    : is executed upon exit of field
  
  * POSTCHG    : is executed on field content change 

  * PREVAL     : is executed before validating any new entry

  * VALFLD     : is executed after field change and validation

  * VALIDATE   : this is the same trigger as VALFLD

  * DEFAULT    : Defines the default value of the field to be set if the setDefault() method is called (this method is automatically called when the user choose the insert command)

  * FORMAT     : Not defined actually

  * ACCESS     : ACCESS is a special trigger that defines how a field can be accessed. This trigger must return one of these values ACS_SKIPPED, ACS_HIDDEN, ACS_VISIT or ACS_MUSTFILL.

  * VALUE      : equates the value of two fields

  * AUTOLEAVE  : must return a boolean value, if "true" the cursor will move to the next field 

  * PREINS     : is executed before inserting a row of the database

  * PREUPD     : is executed before updating a row of the database

  * PREDEL     : is executed before deleting a row of the database

  * POSTINS    : is executed after inserting a row of the database

  * POSTUPD    : is is executed after updating a row of the database


*Examples*
[source,kotlin]
----
val age = visit(domain = INT(3), position = follow(name)) {
    label = "age"

    trigger(POSTCHG) {
      name.value = "userName"
    }
  }
----

in the example above we will assign the value "userName" to the name field each time we change the value of the age field.

----
val password = mustFill(domain = STRING(20), position = at(2, 1)) {
    label = "password"

    trigger(ACCESS) {
      if (name.value == "hidden") {
        Access.HIDDEN
      } else {
        Access.SKIPPED
      }
    }
}
----

==== Creating Form Blocks

As you already know, a form is composed of blocks. A block is a set of data which are stocked in the database and shown on a form. A block is created in order to either view the content of a database, to insert new data in the database or to update existing data in the database.
To create a block you need first to create a class that extend from FormBlock class here we can specify the buffer size, the rows number and the name of the block as parameter, in second part you need to use insertBlock method that allow you to add the block to the form.

*Syntax*
[source,kotlin]
----
BlockDefinition : "class" blockName ": FormBlock" (buffer: Int, rows: Int, blockName : String) {
                  BlockBody
                  }
                  |
                  "val" blockName = "block"(buffer: Int, rows: Int, blockName : String, blockTitle : String) {
                  BlockBody
                  }
  
BlockBody       : [blockBoder] [blockAlignement] [blockHelp]
                  [blockOptions] [blockTables]  
                  [blocIndices] [blockCommands] [blockTriggers] blockFields
                  [blockContextFooter]                     
----

===== Block Types

There are actually two types of blocks in Visual Galite, the only difference between them in the definition syntax is the buffer Integer.

 * single blocks
  
A single block is a block in which only one single row of a database table is displayed on the form. Each time, the computer will memorize only one entire row and a certain quantity of ID numbers through which it will retrieve another rows from the database if you want to view them.

*Example*
[source,kotlin]
----
class BlockCommand : FormBlock(1, 5, "Commands") {
  ...
}

or

val BlockCommand = block(1, 5, "Commands", "Commands") {
...
}
----
The first integer indicates the block type. In case of a single block, the first integer will always be 1. The second integer indicates the maximal number of the automatically memorized IDs.

* Multiple Blocks

A multiple block is a block in which more than one row are displayed on the form. These rows are retrieved all at once from the database and are memorized by the computer. Actually, you can define the number of the displayed rows which can be less than this of the memorized rows. In this case, there will be no need anymore to retrieve the hidden rows from the database when you want to view them.

*Example*
[source,kotlin]
----
class BlockCommand : FormBlock(10, 5, "Commands") {
  ...
}

or

val BlockCommand = block(10, 5, "Commands", "Commands") {
...
}
----
The first integer indicates the number of rows to be automatically memorized while the second defines the number of displayed rows. Notice the first integer value must always be greater than 1.
 
===== Block Names

The example bellow show how to create a block, you need to specify the block title as parameter in the FormBlock function.

*Example*
[source,kotlin] 
----
class Degree : FormBlock(10, 5, "Degree Block")

or

val Degree = block(10, 5, "Degree Block", "Degree Block") {
...
}
----

===== Block superClass and Interface

A Block may extend a superClass and implements one or more Interface. In this example we will implement the interface VConstants.

*Example*
[source,kotlin]
----
class BlockCommand : FormBlock(10, 5, "Degree Block"), VConstants
----

===== Block Border

You can insert the optional border statement that defines the Block's frame type into the init block. Besides, the Title of the block will appear only if the Block's Border type has been specified. There are actually four Border options defined into VConstants interface :

* BRD_LINE to frame the block with lines.
* BRD_RAISED  to enhance a block by setting it on the foreground.
* BRD_LOWERED to put it at the background.
* BRD_ETCHED  to carve a frame in the form.

*Example*
[source,kotlin]
----
inner class Degree : FormBlock(10, 5, "Degree Block") {
    init {
          border = VConstants.BRD_LINE
    }
}
----

===== Block Alignment

Alignment statements are useful to align a block(source block) referring to another one(target block).
Use the align method and you have to specify the referred block name followed by one or many pairs of two fields  the pairs are separated by a comma.
As for the pair fields, the one in the left is the source block field while the other one is for the target block field.

For Example, let us suppose we have a multiple block Prices with 4 columns,
with column 3 filled with Quantities and Column 4 with Prices, we also have a single block TotalPriceswith two fields totalQuantity and totalPrices, we want these fields to be aligned with the correct fields of the Prices block, so we specify that the totalQuantity field is aligned with the field quantity of the block Prices, same thing for totalPrice field it's aligned with the price field of the block Prices:

*Example*
[source,kotlin]
----
val targetBlock = insertBlock(Prices())

val TotalPrices = block(1, 1, "Total", "Total block") {

  val totalQuantity = visit(INT(3), position = at(1, 1)) {
    label = "Total"
    help = "Total"
  }
  val totalPrice = visit(INT(7), position = at(1, 2)) {}

  align(targetBlock, totalQuantity to targetBlock.quantity, totalPrice to targetBlock.price)
}
----

===== Block Help

This optional command is used to define the help text for each field of the block. You need to set the value of help property.

*Example*
 	
[source,kotlin]
----
inner class Degree : FormBlock(10, 5, "Degree Block") {
    init {
          border = VConstants.BRD_LINE
          help = "test"
          ...
    }
}
----

===== Block Options
You need to use options function in your block to specify block options. you can find the list of available options in BlockOption class :

 * NOCHART : Disables the chart(grid) rendering of a multiple bloc to make it look like a single block.Only possible on multiple blocks displaying only one row, Besides the fields must be positioned with the AT command.
 * NODETAIL : Disables the positioning of fields and displays the block as a chart (grid), Only possible on multiple blocks, the fields should not be positioned with the AT command.
 * NODELETE :  Prevent the user from removing fields content.
 * NOINSERT :  Prevent the user from inserting data in fields.
 * NOMOVE   :  Prevent the user from moving between records.
 * ACCESS_ON_SKIPPED : Makes the block accessible even if or its fields have SKIPPED access.
 * UPDATE_INDEX : If used, saving a block would delete all its rows and reinsert them one by one, by doing so, you can update the table rows even when you change the index fields without worrying about the "row already exist exception".

[source,kotlin]
----
inner class Degree : FormBlock(10, 5, "Degree Block") {
    init {
          options(BlockOption.NODETAIL)
          ...
    }
}
----

===== Block Tables
 
When making use of this section, you have to type the function table and enter the table name, assign this function to an variable. This variable will further be used as a shorthand in place of the complete table name in order to access to the table. These names refer to certain tables in the database whereby the first table is the one on which the user will work. The remaining tables are the so-called "look-up tables", i.e tables that are associated with the first one.

*Syntax:*
 	
[source,kotlin]
----
BlockTables:   "table"  "(" SimpleName ")" [BlockTables]*
----

*Example*
 	
[source,kotlin]
----
inner class School : FormBlock(1, 1, "School") {
  val L = table(Lessons)
  val P = table(Lecturers)
  val R = table(Rooms)
  ...
}
----

The user will make use of these look-up tables as references
when bringing in changes in the principal table.

===== Block Indexes

If you plan to enter one index or more when defining your fields, you also have to define one index text or more which will appear if you make a mistake by entering an indexed data or a data combination twice. This command can be followed by an error message contained in a string.

*Syntax:*
 	
[source,kotlin]
----
BlockIndices:   "index("  message : String  ")" [BlockIndices]*
----

*Example*
 	
[source,kotlin]
----
inner class Degree : FormBlock(1, 1, "Degree") {
  val unique = index(message = "This data already exists")
  ...
}
----
===== Block Commands

Block commands are commands accessible only from the block where they are called. There are Three ways to call block commands:

 * *Calling A Standard Command*

Structure of command:

[source,kotlin]
----
"command (" SimpleItemName  ")" { action = " {KOTLIN Code} }

Example
command(item = Validate) {
  action = {
    validate ()
  }
}
----

 *  *Calling The Block Commands With Modes*

Blocks have 3 possible Modes: 

 * QUERY  : When querying the database
 * INSERT : When inserting a new row in the database
 * UPDATE : When updating rows in the database

You can combine these modes with the previous block command structure to have more control over your command
Use the mode function inside you command body declaration to set the modes :

*Syntax*
[source,kotlin]
----
"command (" SimpleItemName  ")" { BlockMode }

BlockMode: "mode(" ModeName* ")"
----
This means that the command called is only accessible when the block is in the specified Mode.

*Example*
[source,kotlin]
----
command(item = Validate) {
    mode(VConstants.MOD_UPDATE, VConstants.MOD_QUERY)
    action = {
      validate ()
    }
}
----

 * *Calling The Block Commands With Modes And An Access Modifier*

in Galite, a field can have different access types or modifiers, here is the definition of the four available access modifiers listed by ascending level.
 
 * HIDDEN : HIDDEN field are invisible in the form, they are used to store hidden operations and database joins.
 * SKIPPED : SKIPPED fields are read only fields, you can read the value but you can't modify it.
 * VISIT : fields with this access type are accessible, can be modified but not necessary.
 * MUSTFILL : MUSTFILL fields are accessible fields that the user must fill with a value.
  
In the block command section, you can set the highest access level for the block fields according to the mode in wich the block would be ording to the mode in which the block would be.

*Example*
[source,kotlin]
----
blockVisibility(Access.SKIPPED, Modes.QUERY, Modes.UPDATE)
blockVisibility(Access.HIDDEN, Modes.UPDATE)
blockVisibility(Access.VISIT, Modes.QUERY)
----

In the first example, all fields in the block will be either SKIPPED or HIDDEN in the query and update modes and can neither be MUSTFILL nor VISIT.
For the second example, all the fields in the block will be HIDDEN when the block is in update mode.
In the last example, all the fields in the block will be either VISIT, SKIPPED or HIDDEN in the query mode and can not be MUSTFILL.

===== Block Triggers

The block triggers are the same as form triggers on the block level. There are actually 20 block triggers you can use to execute actions once they are fired.

*Syntax*
[source,kotlin]
----
 BlocTrigger: "trigger(" TriggerAction : BlocEventList ")"

 BlocEventList: BlockEvent [,BlockEvent]*
----

Concerning the trigger action, which is the action to execute when the trigger is activated they can by :
 ** {KOTLIN code}


Here is a list of all available block triggers or block events in Galite.

 ** PREQRY  : executed before querying the database
 ** POSTQRY : executed after querying the database
 ** PREDEL  : executed before a row is deleted
 ** POSTDEL : executed after a row is deleted
 ** PREINS  : executed before a row is inserted
 ** POSTINS : executed after a row is inserted
 ** PREUPD  : executed before a row is updated
 ** POSTUPD : executed after a row is updated
 ** PRESAVE : executed before saving a row
 ** PREREC  : executed upon record entry		
 ** POSTREC : executed upon record exit
 ** PREBLK  : executed upon block entry
 ** POSTBLK : executed upon block exit
 ** VALBLK  : executed upon block validation
 ** VALREC  : executed upon record validation
 ** DEFAULT : is executed when the block is in the InsertMode. This trigger becomes active when the user presses the key F4. It will then enable the system to load standard values which will be proposed to the user if he wishes to enter new data.
 ** INIT    : executed upon block initialization
 ** RESET   : executed upon Reset command (ResetForm)
 ** CHANGED : a special trigger that returns a boolean value of wether the block have been changed or not, you can use it to bypass the system control for changes this way : 
----
 trigger(CHANGED) {
   return false;
 }
----

 ** ACCESS  : defines whether a block can or not be accessed, it must always return a boolean value
 
----
  trigger(ACCESS) {
    return Block.getMode() == MOD_QUERY
    // Tests if the block is in query mode,
    this block is only accessible on query mode
  }
----
 
*Examples*
[source,kotlin]
----
object Degree : FormBlock(10, 5, "Degree block") {

  trigger(PREBLK, INIT) {
   KOTLIN code
  }

  trigger(PREINS) {
   println("Inserting date");
   ...
  }
  ...
}
----
 
===== Block Fields Declaration

In this section, all you have to do is to write at least on block field definition that begins with an access modifier and ends with brace "}", you can enter as much fields as you may need
following the field definition we saw in the previous chapter.

*Examples*
[source,kotlin]
----
val name = visit(domain = STRING(25), position = at(1, 2)) {
      label = "Last name"
      help = "The client name"
      columns(c.name)
}
----

===== Block Context Footer

In this section of the block, you can write local functions, define inner classes, override command actions, define your data members.
The elements you write in the block Context Footer are accessible in the concerned block and are written in KOTLIN code.
  
 
==== Creating Forms 

There are actually two types of forms in Galite, normal forms and BLOC INSERT forms which are special forms containing blocks that you may insert in other forms. +
A form begins always with FORM and ends with END FORM, while a BLOC INSERT form begins with BLOC INSERT and ends with END INSERT.

In Galite to create a form you need to extend from this list off classes :

 ** Form  : Represents a form.
 ** ReportSelectionForm : Represents a report selection form.
 ** DictionaryForm : Represents a dictionary form.

When creating a form, you will have to include the block and the field definitions. Moreover, you will have to define the menus as well as the different commands. Finally, you can also define some form triggers. Concretely, the structure is the following:

*Syntax:*
[source,kotlin] 
----
FormDef :
          FormName ":" QualifiedName [,QualifiedName]*
          {
              "title ="  formTitle : String
              ["locale ="  formLocalization : String]
              [MenuDefinition]
              [ActorDefinition] [TypeDefinition]
              [CommandDefinition] [InsertDefinition]

              [FormCommands] [FormsTriggers] [BlocksDefinition]
          }
----

===== Form Localization

This is an optional step in which you may define the language of your forms menus and messages, the latter have to be defined in xml files.

*Syntax*
[source,kotlin]
----
"locale =" formLocalization : String
----
*Example:*
[source,kotlin]
----
class LecturersForm : Form() {
    override val locale = Locale.UK
}
----

===== Form Title

Every form have can have a title (optional).

*Syntax*
[source,kotlin]
----
"title =" formTitle : String
----

*Example*
 	
[source,kotlin]
----
class LecturersForm : Form() {
    override val title = "Lecturers List"
}
----

===== Form Superclass And Interfaces

 * *Superclass:*

*Syntax:*
 	
[source,kotlin]
----  
SuperForm:   ":" QualifiedName
----
Every form is a class that may extend another Kotlin class by using the optional keyword :. Otherwise,  Galite will automatically take over the java.lang.Object QualifiedName.

*Example*
 	
[source,kotlin]
----
class ServiceRegister : VReportSelectionForm() {
    ...
}
----
In other words, the class declaration you have just made specifies the direct superclass of the current class.

 * *Interfaces*

You can also specify interfaces which the form may implement by using the ":" option. When used in a form declaration, this option then lists the names of interfaces that are direct superInterfaces of the class being declared. Thus, you will have the following structure:

*Syntax*

[source,kotlin]
----
Interface :  ":" QualifiedName [,QualifiedName]*
----

*Example:*
 	
[source,kotlin]
----
class RecordRegistering : VReportSelectionForm(), VConstants {
    ...
}
----

===== Menus Definition

Defining a menu means adding an entry to the menu bar in the top of the form, you can add actors to this menu later by specifying the menu name in the actor definition.

*Syntax:*
 	
[source,kotlin]
----  
MenuDefinition: "menu (" label : String ")"
----

*Example*
 	
[source,kotlin]
----
class ListLecturersForm : ReportSelectionForm() {
  override val locale = Locale.UK
  override val title = "List of the Lecturers"
  val file = menu("file")
  ...
}
----

===== Actors Definition

An Actor is an item to be linked with a command, if its ICON is specified, it will appear in the icon_toolbar located under the menu bar, otherwise, it will only be accecible from the menu bar.
ICON and KEY are optional, the KEY being the keyboard shortcut to assign to the actor.


*Syntax:*
 	
[source,kotlin]
----
ActorDefinition:  "actor"(
                    "ident" = SimpleName,
                    "menu" = SimpleName,
                    "label" = label : String,
                    "help" = helpText : String,
                  ) {
                    [key = key  : String]
                    [icon = icon : String]
                  }
----

*Example*
 	
[source,kotlin]
----

class ListLecturersForm : ReportSelectionForm() {
  override val locale = Locale.UK
  override val title = "List of the Lecturers"
  val file = menu("file")
  val cut = actor(
    ident = "cut",
    menu = file,
    label = "cut",
    help = "cut element",
  ) {
    key = Key.F2          // key is optional here
    icon = "CutIcon"  // icon is optional here
  }
  ....
}
----

===== Types Definition

After having defined your menus and actor, you can enter different field types definitions based on the standard field types or code field types, you can also use SELECT commands
to customize these new types. 

*Example*
 	
[source,kotlin]
----
class ListLecturersForm : ReportSelectionForm() {

    object Days: CodeDomain<Int>() {
      init {
        "Sunday" keyOf 1
        "Monday" keyOf 2
        "Tuesday" keyOf 3
        "Wednesday" keyOf 4
        "Thursday" keyOf 5
        "Friday" keyOf 6
        "Saturday" keyOf 7
      }
    }

    object CurrentDegree : ListDomain<String>(20) {
      override val table = query(Degree.selectAll())

      init {
        "Symbol" keyOf Degree.Symbol
        "Description" keyOf Degree.Description
      }
    }
}
----

===== Commands Definition

In this section you may want to define new commands, to do so, all you need is an already defined Actor from which you will call the command in order to execute an Action on the form.
every command have a effective ray of action (VField, VBlock, VForm)

 * Simply writing the body of the action using the  ACTION command, the parameters are optional and can be VField, VBlock, VForm. 

Command Defined in this section can be form level commands, block level commands or field level commands, this will depend on the action called by the command and where the command is actualy called.
 
*Syntax*
[source,kotlin]
----
cmdDef  : "command (" SimpleItemName  ")" { commandBody }

commandBody: { KOTLIN statements }
----

*Example*
Writing the action's body :

[source,kotlin]
----
command(item = PrintBlock) {
    action = {
        blockName.validate();
        blockName.getForm().close(VForm.CDE-Validate);
    }
}

----

After the different definitions we have made (types, menus, actors,commands), we need to begin the declaration of our form.Here, we will set up the structure and the behaviour of the form throw 4 sections :

 * Form Options
 * Form Commands
 * Form Triggers
 * Blocks

===== Form Commands Declaration

There still one more think to know about form command declaration, in fact, you can also control the accessibility to a command by the Mode of the form.+
A form have 3 possible Modes :

 * QUERY  : When inquiring the database
 * INSERT : When inserting a row in the database
 * UPDATE : When updating a row in the database

The Syntax to use command with modes is the following :

*Syntax*
[source,kotlin]
----
"command (" SimpleItemName  ")" { BlockMode }

BlockMode: "mode(" ModeName* ")"
----
This means that the command called is only accessible when the block is in the specified Mode.

*Example*
[source,kotlin]
----
command(item = Validate) {
    mode(VConstants.MOD_UPDATE, VConstants.MOD_QUERY)
    action = {
      validate ()
    }
}
----

===== Form Triggers Definition
Form Triggers are special events that once switched on you can execute a set of actions defined by the following syntax :

*Syntax*
----
FormTrigger  :  "trigger(" TriggerAction : FormEventList ")"
FormEventList:  FormEvent [,FormEvent]*
----

Galite actually defines 6 Form Triggers or Form Events :
 
 * INIT      : executed when initializing the form and before the PREFORM Trigger, also executed at ResetForm command
 * PREFORM   : executed before the form is displayed and after the INIT Trigger, not executed at ResetForm command
 * POSTFORM  : executed when closing the form
 * QUITFORM  : actually not available
 * RESET     : executed upon ResetForm command
 * CHANGED   : a special trigger that returns a boolean value of whether the form have been changed or not, you can use it to bypass the system control for changes this way : 
----
val postform = trigger(POSTFORM) {
  println("post form trigger works")
}
----

*Examples*
----
val preform = trigger(INIT) {
    println("init form trigger works")
}

val initialisation = trigger(INIT, PREFORM) {
    //KOTLIN statements
}
----

===== Form Pages 

You can create Pages in your form using the page function after the trigger declaration section,this is optional and will create a Tab for each page you create under the form's toolbar.
You can put as much blocks you want in each page, the same goes for form without pages.

*Example*
----
val p1 = page("Page1")
----

==== Form Context Footer

In this section of the form, you can write your local functions, define inner classes, override command actions, define your data members.
The elements you write in the forms Context Footer are accessible in all the form and are writen in KOTLIN code.
